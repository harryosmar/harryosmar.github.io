3:I[6702,[],""]
5:I[8097,[],""]
6:I[4865,["513","static/chunks/513-54c786173a9c666c.js","122","static/chunks/122-1e2541ae7fd00b15.js","948","static/chunks/app/(content)/layout-98a57fd1c16e634e.js"],"NavTabs"]
7:I[4387,["185","static/chunks/app/layout-dc2409b386032b48.js"],"ThemeProvider"]
4:["page","1","d"]
8:{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"}
9:{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"}
a:{"display":"inline-block"}
b:{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0}
0:["298uBJO2xnu6n8Q4Wbxdz",[[["",{"children":["(content)",{"children":["articles",{"children":["page",{"children":[["page","1","d"],{"children":["__PAGE__?{\"page\":\"1\"}",{}]}]}]}]}]},"$undefined","$undefined",true],["",{"children":["(content)",{"children":["articles",{"children":["page",{"children":[["page","1","d"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(content)","children","articles","children","page","children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(content)","children","articles","children","page","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(content)","children","articles","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[null,["$","div",null,{"className":"min-h-screen bg-white dark:bg-neutral-900","children":[["$","$L6",null,{}],["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","(content)","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]]}]],null],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/7b555c975a649a76.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":["$","body",null,{"className":"__variable_1e4310 __variable_c3aa02 min-h-screen font-sans antialiased bg-background text-foreground dark:bg-neutral-900 dark:text-neutral-100 transition-colors","children":["$","$L7",null,{"children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":"$8","children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":"$9","children":"404"}],["$","div",null,{"style":"$a","children":["$","h2",null,{"style":"$b","children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]}]}]],null],null],["$Lc",null]]]]
c:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Articles | Harry Osmar Sitohang"}],["$","meta","3",{"name":"description","content":"Thoughts, tutorials, and insights about web development, software engineering, and technology."}],["$","meta","4",{"name":"robots","content":"index, follow"}],["$","meta","5",{"property":"og:title","content":"Articles"}],["$","meta","6",{"property":"og:description","content":"Thoughts, tutorials, and insights about web development, software engineering, and technology."}],["$","meta","7",{"property":"og:url","content":"https://www.harryosmarsitohang.com/articles/page/1"}],["$","meta","8",{"property":"og:type","content":"website"}],["$","meta","9",{"name":"twitter:card","content":"summary"}],["$","meta","10",{"name":"twitter:title","content":"Articles"}],["$","meta","11",{"name":"twitter:description","content":"Thoughts, tutorials, and insights about web development, software engineering, and technology."}],["$","link","12",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","meta","13",{"name":"next-size-adjust"}]]
1:null
d:I[6243,["513","static/chunks/513-54c786173a9c666c.js","189","static/chunks/189-76139bfb22cdcfc2.js","829","static/chunks/app/(content)/articles/page/%5Bpage%5D/page-4df37524aaef99fa.js"],"LastVisitedPageHandler"]
e:I[4315,["513","static/chunks/513-54c786173a9c666c.js","189","static/chunks/189-76139bfb22cdcfc2.js","829","static/chunks/app/(content)/articles/page/%5Bpage%5D/page-4df37524aaef99fa.js"],"default"]
14:I[6676,["513","static/chunks/513-54c786173a9c666c.js","189","static/chunks/189-76139bfb22cdcfc2.js","829","static/chunks/app/(content)/articles/page/%5Bpage%5D/page-4df37524aaef99fa.js"],"Pagination"]
f:T3f66,<p>Caching is an essential optimization technique in web development, helping <strong>reduce database load</strong> and significantly <strong>speeding up response times</strong>. If you‚Äôre building a Strapi-based application, adding a caching layer can make your API lightning-fast while maintaining scalability.</p>
<h2 id="requirements">Requirements<span class="ml-2 opacity-0 hover:opacity-100"><a href="#requirements" class="anchor" aria-hidden="true">#</a></span></h2>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@strapi/strapi"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"5.1.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"ioredis"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^5.4.1"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>

</code></pre>
<h2 id="-why-add-caching-in-strapi">üöÄ Why Add Caching in Strapi?<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-why-add-caching-in-strapi" class="anchor" aria-hidden="true">#</a></span></h2>
<p>Strapi provides a robust backend for APIs, but database queries can become a bottleneck as traffic grows. By adding caching to Strapi:</p>
<ul>
<li>Boost API <strong>response time</strong>: Serve cached data directly, avoiding repetitive database queries.</li>
<li><strong>Reduce</strong> backend load: Offload frequent reads to an in-memory store like Redis.</li>
<li>Enhance <strong>scalability</strong>: Handle higher traffic without straining your database.</li>
</ul>
<h2 id="flow">Flow<span class="ml-2 opacity-0 hover:opacity-100"><a href="#flow" class="anchor" aria-hidden="true">#</a></span></h2>
<h3 id="normal-flow">Normal flow<span class="ml-2 opacity-0 hover:opacity-100"><a href="#normal-flow" class="anchor" aria-hidden="true">#</a></span></h3>
<img src="/images/mermaid/mermaid-b87006366ef0ef03ba349357c7f73b87.svg" alt="Mermaid diagram">
<h3 id="clear_cache-flow">clear_cache Flow<span class="ml-2 opacity-0 hover:opacity-100"><a href="#clear_cache-flow" class="anchor" aria-hidden="true">#</a></span></h3>
<img src="/images/mermaid/mermaid-e3b912d91bb683f397b46239682fa223.svg" alt="Mermaid diagram">
<h2 id="-installing-redis-for-caching">üì¶ Installing Redis for Caching<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-installing-redis-for-caching" class="anchor" aria-hidden="true">#</a></span></h2>
<p>Install <code>ioredis</code> to interact with Redis, because we're using redis as cache provider.</p>
<pre><code class="hljs language-shell">npm install ioredis
</code></pre>
<h2 id="Ô∏è-setting-up-middleware-in-strapi">üõ†Ô∏è Setting Up Middleware in Strapi<span class="ml-2 opacity-0 hover:opacity-100"><a href="#Ô∏è-setting-up-middleware-in-strapi" class="anchor" aria-hidden="true">#</a></span></h2>
<p>To add a custom middleware, Strapi requires you to:</p>
<ol>
<li>Register it in the middleware configuration file (<code>./config/middlewares.ts</code>).</li>
<li>Create the middleware file in directory <code>./src/middlewares/</code>, then implement the middleware logic.</li>
</ol>
<h3 id="1-middleware-registration">1. Middleware Registration<span class="ml-2 opacity-0 hover:opacity-100"><a href="#1-middleware-registration" class="anchor" aria-hidden="true">#</a></span></h3>
<p>In <code>./config/middlewares.ts</code>, register your middleware as a global middleware:</p>
<p>register new <code>global::cache-middleware</code></p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [
  <span class="hljs-string">'strapi::logger'</span>,
  <span class="hljs-string">'strapi::errors'</span>,
  <span class="hljs-string">'strapi::security'</span>,
  <span class="hljs-string">'strapi::cors'</span>,
  <span class="hljs-string">'strapi::poweredBy'</span>,
  <span class="hljs-string">'strapi::query'</span>,
  <span class="hljs-string">'strapi::body'</span>,
  <span class="hljs-string">'strapi::session'</span>,
  <span class="hljs-string">'strapi::favicon'</span>,
  <span class="hljs-string">'strapi::public'</span>,
  <span class="hljs-string">'global::cache-middleware'</span> <span class="hljs-comment">// Register cache middleware here</span>
];
</code></pre>
<h3 id="2--create-the-cache-middleware-file">2. üß© Create the Cache Middleware file<span class="ml-2 opacity-0 hover:opacity-100"><a href="#2--create-the-cache-middleware-file" class="anchor" aria-hidden="true">#</a></span></h3>
<p>Create a new middleware file, <code>cache-middleware.ts</code>, in the <code>./src/middlewares/</code> directory</p>
<p>Full Implementation</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Redis</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'ioredis'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> (config, { strapi }) => {
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_TIMEOUT</span> = <span class="hljs-number">1000</span>; <span class="hljs-comment">// Connection timeout</span>
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_EXPIRATION</span> = process.<span class="hljs-property">env</span>.<span class="hljs-property">REDIS_CACHE_EXPIRATION</span> || <span class="hljs-number">3600</span>; <span class="hljs-comment">// Default TTL: 1 hour</span>

    <span class="hljs-keyword">const</span> redis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Redis</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">REDIS_URL</span> || <span class="hljs-string">'redis://localhost:6379'</span>, {
        <span class="hljs-attr">connectTimeout</span>: <span class="hljs-variable constant_">CACHE_TIMEOUT</span>,
        <span class="hljs-attr">commandTimeout</span>: <span class="hljs-variable constant_">CACHE_TIMEOUT</span>,
        <span class="hljs-attr">retryStrategy</span>: <span class="hljs-function">(<span class="hljs-params">times</span>) =></span> (times &#x3C;= <span class="hljs-number">1</span> ? <span class="hljs-variable constant_">CACHE_TIMEOUT</span> : <span class="hljs-literal">null</span>)
    });

    redis.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
        strapi.<span class="hljs-property">log</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Redis connection error:'</span>, error);
    });

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">async</span> (ctx, next) => {
        <span class="hljs-keyword">const</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
        <span class="hljs-keyword">const</span> matches = ctx.<span class="hljs-property">path</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/^\/?api(\/.+)$/</span>);

        <span class="hljs-comment">// Skip non-GET requests or non-API paths</span>
        <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">method</span> !== <span class="hljs-string">'GET'</span> || !matches || matches.<span class="hljs-property">length</span> !== <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">const</span> queryParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(ctx.<span class="hljs-property">querystring</span>);
        <span class="hljs-keyword">const</span> shouldClearCache = queryParams.<span class="hljs-title function_">get</span>(<span class="hljs-string">'clear_cache'</span>) === <span class="hljs-string">'1'</span>;
        queryParams.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'clear_cache'</span>); <span class="hljs-comment">// Remove clear_cache from cache key</span>
        <span class="hljs-keyword">const</span> cacheKey = <span class="hljs-string">`strapi:cache:<span class="hljs-subst">${ctx.path}</span>?<span class="hljs-subst">${<span class="hljs-built_in">decodeURIComponent</span>(queryParams.toString())}</span>`</span>;

        <span class="hljs-keyword">const</span> <span class="hljs-title function_">tryRedisOperation</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">operation, retryCount = <span class="hljs-number">1</span></span>) => {
            <span class="hljs-keyword">try</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">operation</span>();
            } <span class="hljs-keyword">catch</span> (error) {
                <span class="hljs-keyword">if</span> (retryCount > <span class="hljs-number">0</span>) {
                    strapi.<span class="hljs-property">log</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'Redis operation failed, retrying...'</span>);
                    <span class="hljs-keyword">return</span> <span class="hljs-title function_">tryRedisOperation</span>(operation, retryCount - <span class="hljs-number">1</span>);
                }
                <span class="hljs-keyword">throw</span> error;
            }
        };

        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (shouldClearCache) {
                <span class="hljs-keyword">await</span> <span class="hljs-title function_">tryRedisOperation</span>(<span class="hljs-function">() =></span> redis.<span class="hljs-title function_">del</span>(cacheKey));
                strapi.<span class="hljs-property">log</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`Cache cleared for: <span class="hljs-subst">${cacheKey}</span>`</span>);
                ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">'X-Cache'</span>, <span class="hljs-string">'CLEARED'</span>);
            }

            <span class="hljs-keyword">const</span> cachedResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">tryRedisOperation</span>(<span class="hljs-function">() =></span> redis.<span class="hljs-title function_">get</span>(cacheKey));
            <span class="hljs-keyword">if</span> (cachedResponse &#x26;&#x26; !shouldClearCache) {
                <span class="hljs-keyword">const</span> { body, headers, status } = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(cachedResponse);
                ctx.<span class="hljs-property">body</span> = body;
                ctx.<span class="hljs-property">status</span> = status;
                <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(headers).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =></span> ctx.<span class="hljs-title function_">set</span>(key, value <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>));
                ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">'X-Cache'</span>, <span class="hljs-string">'HIT'</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();

                <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) {
                    <span class="hljs-keyword">const</span> response = {
                        <span class="hljs-attr">body</span>: ctx.<span class="hljs-property">body</span>,
                        <span class="hljs-attr">headers</span>: ctx.<span class="hljs-property">response</span>.<span class="hljs-property">headers</span>,
                        <span class="hljs-attr">status</span>: ctx.<span class="hljs-property">status</span>
                    };
                    <span class="hljs-keyword">await</span> <span class="hljs-title function_">tryRedisOperation</span>(<span class="hljs-function">() =></span>
                        redis.<span class="hljs-title function_">setex</span>(cacheKey, <span class="hljs-variable constant_">CACHE_EXPIRATION</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(response))
                    );
                    ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">'X-Cache'</span>, shouldClearCache ? <span class="hljs-string">'CLEARED+MISS'</span> : <span class="hljs-string">'MISS'</span>);
                } <span class="hljs-keyword">else</span> {
                    ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">'X-Cache'</span>, <span class="hljs-string">'SKIP'</span>);
                }
            }
        } <span class="hljs-keyword">catch</span> (error) {
            ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">'X-Cache'</span>, <span class="hljs-string">'ERROR'</span>);
            strapi.<span class="hljs-property">log</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Cache middleware error:'</span>, error);
            <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();
        }

        ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">'X-Response-Time'</span>, <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now() - start}</span>ms`</span>);
    };
};
</code></pre>
<h2 id="environment-variables-to-configure-cache">Environment variables to configure cache<span class="ml-2 opacity-0 hover:opacity-100"><a href="#environment-variables-to-configure-cache" class="anchor" aria-hidden="true">#</a></span></h2>
<p>Make sure to run command below, before start the strapi app</p>
<pre><code class="hljs language-shell">export REDIS_CACHE_EXPIRATION=3600
export REDIS_URL=redis://:password@localhost:6379
export CACHE_TIMEOUT=1000
</code></pre>
<h2 id="-cache-invalidation-with-query-parameters">üîÑ Cache Invalidation with Query Parameters<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-cache-invalidation-with-query-parameters" class="anchor" aria-hidden="true">#</a></span></h2>
<p>Add <code>?clear_cache=1</code> to any API endpoint to clear its cache. For example:</p>
<pre><code class="hljs language-shell">GET /api/users?clear_cache=1
</code></pre>
<h2 id="-cache-response-headers">üìù Cache Response Headers<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-cache-response-headers" class="anchor" aria-hidden="true">#</a></span></h2>
<p>To track cache usage, the middleware sets an X-Cache header:</p>
<ul>
<li><code>HIT</code>: Data was served from the cache.</li>
<li><code>MISS</code>: Data was retrieved from the source and cached.</li>
<li><code>CLEARED</code>: Cache was invalidated for the request.</li>
<li><code>CLEARED+MISS</code>: Cache was cleared, and fresh data was stored.</li>
<li><code>ERROR</code>: Redis operation failed.</li>
</ul>
<h2 id="-conclusion">üöÄ Conclusion<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-conclusion" class="anchor" aria-hidden="true">#</a></span></h2>
<p>Adding a Redis-powered cache middleware to Strapi can drastically improve performance, scalability, and user experience. By following this guide, you‚Äôll have a flexible caching solution ready to handle high traffic while keeping your application responsive.</p>
<p>Give your Strapi API a performance boost‚Äîstart caching with Redis today! üöÄ</p>10:T1548,<p>FFMPEG WASM is a powerful library that brings the capabilities of FFMPEG, the industry-standard multimedia tool, directly to the browser. By leveraging WebAssembly, it enables client-side video and audio processing, including recording, transcoding, and even streaming‚Äîall without relying on server-side infrastructure.</p>
<p>Explore the demo: <a href="https://gitlab.com/harry.sitohang/react-ffmpeg-wasm#">FFMPEG WASM Demo Project</a>.</p>
<img src="/images/mermaid/mermaid-41ceb72b91dfdd270008de8b93556b78.svg" alt="Mermaid diagram">
<h2 id="-why-use-ffmpeg-wasm">üöÄ Why Use FFMPEG WASM?<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-why-use-ffmpeg-wasm" class="anchor" aria-hidden="true">#</a></span></h2>
<ul>
<li>
<p><strong>Offloads Server Load</strong>: Shift intensive video encoding tasks to the client-side, reducing server costs and improving scalability.</p>
</li>
<li>
<p>Full Browser Compatibility: Enables real-time video and audio <strong>processing directly in user agents</strong> (browsers).</p>
</li>
<li>
<p>SharedArrayBuffer for Multi-Threading: Leverages efficient memory management and <strong>multi-threading</strong> to handle large media files seamlessly.</p>
</li>
<li>
<p>Versatile Media Formats: Transcode and <strong>convert</strong> between various video and audio formats directly in the browser.</p>
</li>
</ul>
<h2 id="-advantages">üü¢ Advantages<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-advantages" class="anchor" aria-hidden="true">#</a></span></h2>
<ul>
<li>Scalable Architecture: Encode, convert, and process media <strong>on the client side</strong>, freeing server resources.</li>
<li>Efficient Multi-Threading: Uses SharedArrayBuffer to minimize memory usage and boost <strong>performance</strong>.</li>
<li>Cross-Platform: Works across modern browsers with <strong>WebAssembly</strong> support.</li>
<li>No Installation Needed: <strong>Lightweight</strong> and runs entirely in the browser.</li>
</ul>
<p>.</p>
<h2 id="-limitations">üî¥ Limitations<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-limitations" class="anchor" aria-hidden="true">#</a></span></h2>
<ul>
<li>Large File Size: The ffmpeg-core.wasm file (~32 MB) <strong>must be downloaded</strong> by the client, which could affect load times.</li>
<li>No RTMP Streaming: While <strong>transcoding</strong> is supported, <del>live streaming</del> to RTMP endpoints is not included.</li>
<li>Complex Headers Setup: Requires CORS and security headers (COEP, COOP, CORP) for enabling features like <strong>SharedArrayBuffer</strong>.</li>
</ul>
<h2 id="-how-to-use-ffmpeg-wasm">üîß How to Use FFMPEG WASM?<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-how-to-use-ffmpeg-wasm" class="anchor" aria-hidden="true">#</a></span></h2>
<h3 id="1-install-static-handler-for-headers">1. Install Static Handler for Headers<span class="ml-2 opacity-0 hover:opacity-100"><a href="#1-install-static-handler-for-headers" class="anchor" aria-hidden="true">#</a></span></h3>
<p>To use <code>SharedArrayBuffer</code> in the browser, add these headers to your server:</p>
<pre><code class="hljs language-js">{
    <span class="hljs-string">"Cross-Origin-Embedder-Policy"</span>: <span class="hljs-string">"require-corp"</span>,
    <span class="hljs-string">"Cross-Origin-Opener-Policy"</span>: <span class="hljs-string">"same-origin"</span>
}
</code></pre>
<p>Serve your static files with:</p>
<pre><code class="hljs language-shell">npx static-handler --cors --coop --coep --corp -p 8080 ./
</code></pre>
<h3 id="2efficient-media-processing">2.Efficient Media Processing<span class="ml-2 opacity-0 hover:opacity-100"><a href="#2efficient-media-processing" class="anchor" aria-hidden="true">#</a></span></h3>
<p>Transcode videos or process audio files directly in the browser, reducing server dependency.</p>
<h2 id="-real-benefits-of-using-ffmpeg-wasm">üåü Real Benefits of Using FFMPEG WASM<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-real-benefits-of-using-ffmpeg-wasm" class="anchor" aria-hidden="true">#</a></span></h2>
<ul>
<li>On-the-Fly Media Conversion: Easily convert user-uploaded videos to compatible formats <strong>directly in the browser</strong>.</li>
<li>Improved User Experience: Enable users to edit, trim, and enhance videos <strong>without uploading files to a server</strong>.</li>
<li>Cost-Effective: <del>No need for expensive</del> server-side transcoding infrastructure.</li>
</ul>
<h2 id="Ô∏è-demo-in-action">üñ•Ô∏è Demo in Action<span class="ml-2 opacity-0 hover:opacity-100"><a href="#Ô∏è-demo-in-action" class="anchor" aria-hidden="true">#</a></span></h2>
<p>Check out this real-world example <a href="https://gitlab.com/harry.sitohang/react-ffmpeg-wasm#">FFMPEG WASM Demo Project</a>.</p>
<h2 id="-learn-more">üß† Learn More<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-learn-more" class="anchor" aria-hidden="true">#</a></span></h2>
<p>For a deep dive into how SharedArrayBuffer optimizes memory usage and enables multi-threading, read:</p>
<ul>
<li><a href="https://webreflection.medium.com/about-sharedarraybuffer-atomics-87f97ddfc098">About SharedArrayBuffer &#x26; Atomics</a>.</li>
<li><a href="https://ffmpegwasm.netlify.app/">FFMPEG WASM Official Website</a>.</li>
</ul>
<p>By embracing FFMPEG WASM, you bring cutting-edge <strong>video and audio processing</strong> to your browser-based applications‚Äîefficiently and cost-effectively.</p>11:Tc6d,<p>Streaming technologies are evolving to accommodate real-time content delivery with minimal latency. A particularly innovative approach involves <strong>combining WebSockets with FFMPEG</strong> to enable client-side streams to be processed and <strong>forwarded to RTMP channels</strong>. This article will explore the concept, its setup, and the pros and cons of this technique.</p>
<p>Explore the Code:</p>
<p>GitHub Repository: <a href="https://github.com/chuabingquan/pxy">chuabingquan/pxy üé• Proxy livestreams from WebSockets to RTMP</a>.</p>
<h2 id="-how-it-works">üöÄ How It Works<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-how-it-works" class="anchor" aria-hidden="true">#</a></span></h2>
<img src="/images/mermaid/mermaid-8a4bc82f5f343e48a382f53df95e641c.svg" alt="Mermaid diagram">
<h3 id="1-browser-connects-to-websocket-server">1. Browser Connects to WebSocket Server:<span class="ml-2 opacity-0 hover:opacity-100"><a href="#1-browser-connects-to-websocket-server" class="anchor" aria-hidden="true">#</a></span></h3>
<p>The browser streams video data through the WebSocket protocol to the server.</p>
<p><img src="/images/articles/3/in-progress-streaming.png" alt="start streaming to websocket using browser"></p>
<h3 id="2-websocket-server-receives-and-processes-data">2. WebSocket Server Receives and Processes Data:<span class="ml-2 opacity-0 hover:opacity-100"><a href="#2-websocket-server-receives-and-processes-data" class="anchor" aria-hidden="true">#</a></span></h3>
<p>The server receives the WebSocket message, processes the data, and forwards it as an FFmpeg command to the RTMP channel.</p>
<p>The ffmpeg command.
FFmpeg receives the WebSocket input and streams it to an RTMP endpoint for live broadcasting.</p>
<pre><code class="hljs language-shell">
ffmpeg -i - -vcodec copy -f flv -loglevel debug rtmp://localhost:1936/live/demo4
</code></pre>
<p><img src="/images/articles/3/websocket-server-to-rtmp.png" alt="websocket server forward stream messsage to RTMP channel"></p>
<h2 id="-benefits">üì∫ Benefits<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-benefits" class="anchor" aria-hidden="true">#</a></span></h2>
<ul>
<li>üü¢ Ease of Use: Quickly establish a live streaming pipeline with WebSocket and FFmpeg.</li>
<li>üü¢ Minimal Server Overhead: The server acts as a simple proxy, offloading encoding and streaming tasks to FFmpeg.</li>
</ul>
<h2 id="-limitations">üî¥ Limitations<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-limitations" class="anchor" aria-hidden="true">#</a></span></h2>
<ul>
<li>WebSocket Overhead: WebSockets can introduce latency when compared to direct RTMP input.</li>
<li>Dependency on FFmpeg: Requires a working FFmpeg installation on the server.</li>
</ul>
<h2 id="-final-thoughts">üåü Final Thoughts<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-final-thoughts" class="anchor" aria-hidden="true">#</a></span></h2>
<p>Integrating <strong>WebSockets and FFmpeg for live streaming</strong> is an effective way to bridge browser-based video sources and RTMP endpoints.</p>
<p>Start streaming today and unlock new possibilities for browser-based live broadcasting!</p>12:T169e,<p>WebRTC (Web Real-Time Communication) is a powerful and versatile protocol that enables <strong>real-time</strong> communication, video streaming, and file sharing between browsers. If you're looking for a reliable and flexible solution for <strong>live streaming and video playback</strong>, look no further than <strong>MediaMTX</strong>, a Go-based media server that supports multiple streaming protocols including <strong>WebRTC</strong>, <strong>RTMP</strong>, <strong>SRT</strong>, and more.</p>
<p>Explore the Code:</p>
<p>GitHub Repository: <a href="https://github.com/bluenviron/mediamtx">mediamtx Webrtc</a>.</p>
<h2 id="-why-choose-mediamtx-for-webrtc-streaming">üöÄ Why Choose MediaMTX for WebRTC Streaming?<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-why-choose-mediamtx-for-webrtc-streaming" class="anchor" aria-hidden="true">#</a></span></h2>
<p>MediaMTX is an efficient and <strong>ready-to-use</strong> media server that allows you to stream and proxy real-time video and audio content seamlessly. It supports <strong>various protocols</strong> and can be easily integrated with other services to create a powerful live streaming solution.</p>
<p>Key Features:</p>
<ul>
<li>Multi-Protocol Support: MediaMTX supports <strong>WebRTC</strong>, <strong>RTSP</strong>, <strong>RTMP</strong>, and <strong>LL-HLS</strong>, providing flexibility for different types of media streaming.</li>
<li>Real-Time Video Streaming: With <strong>WebRTC</strong>, MediaMTX ensures low-latency streaming for real-time communication.</li>
<li>Built with Go: Developed in Go, MediaMTX is highly performant and easily deployable.</li>
<li>Stream Forwarding: Forward streams to other servers or cloud services such as OSS with HLS.</li>
</ul>
<h2 id="Ô∏è-how-to-get-started-with-mediamtx">üõ†Ô∏è How to Get Started with MediaMTX<span class="ml-2 opacity-0 hover:opacity-100"><a href="#Ô∏è-how-to-get-started-with-mediamtx" class="anchor" aria-hidden="true">#</a></span></h2>
<p>Clone the repository and run the server:</p>
<pre><code class="hljs language-shell">git clone git@github.com:bluenviron/mediamtx.git
cd mediamtx
go mod download
go run main.go
</code></pre>
<p>Once the server is up and running, you can publish your video stream by visiting:</p>
<p><a href="http://localhost:8889/mystream/publish">http://localhost:8889/mystream/publish</a></p>
<h2 id="-live-streaming-with-webrtc">üåê Live Streaming with WebRTC<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-live-streaming-with-webrtc" class="anchor" aria-hidden="true">#</a></span></h2>
<p>Once your server is set up, you can start streaming in real-time with WebRTC. Navigate to the following URL to access live streaming:</p>
<p><a href="http://localhost:8889/mystream/">http://localhost:8889/mystream/</a></p>
<p>WebRTC provides smooth playback with <strong>low latency</strong>, making it ideal for live streaming.</p>
<h2 id="-hls-playback-support">üé¨ HLS Playback Support<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-hls-playback-support" class="anchor" aria-hidden="true">#</a></span></h2>
<p>MediaMTX also supports HLS (HTTP Live Streaming) for playback. To test HLS playback, visit:</p>
<p><a href="http://localhost:8888/mystream">http://localhost:8888/mystream</a></p>
<p>Additionally, you can access the playlist:</p>
<p><a href="http://localhost:8888/mystream/index.m3u8">http://localhost:8888/mystream/index.m3u8</a></p>
<h2 id="-forwarding-streams">üîÑ Forwarding Streams<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-forwarding-streams" class="anchor" aria-hidden="true">#</a></span></h2>
<p>MediaMTX allows you to forward streams to other servers. Here's an example of how to use FFmpeg to forward the stream to another RTMP server:</p>
<pre><code class="hljs language-shell">ffmpeg -re -i http://localhost:8888/$MTX_PATH/index.m3u8 \
  -c:v libx264 -c:a aac -b:a 192k -ar 48000 -af "equalizer=f=1000:t=q:w=1:g=5,loudnorm" \
  -f flv rtmp://localhost:1936/live/$MTX_PATH
</code></pre>
<p>This setup allows you to broadcast your live stream to other platforms, expanding your audience reach.</p>
<h2 id="-advantages">üü¢ Advantages<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-advantages" class="anchor" aria-hidden="true">#</a></span></h2>
<ul>
<li>Real-Time Streaming: WebRTC ensures smooth, low-latency streaming for a better user experience.</li>
<li>Protocol Flexibility: Supports multiple protocols, making it easy to switch based on your needs.</li>
<li>Forward Streams: Forward your streams to other servers, such as OSS, using FFmpeg and HLS.</li>
<li>Easy Setup: MediaMTX's simple configuration makes it easy to get started with live streaming.</li>
</ul>
<h2 id="-limitations">üî¥ Limitations<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-limitations" class="anchor" aria-hidden="true">#</a></span></h2>
<ul>
<li></li>
<li>Advanced Features May Require Custom Configuration: For more advanced features, you may need to tweak the server setup.</li>
<li>System Resources: Running multiple real-time streams can <strong>consume significant</strong> system resources.</li>
</ul>
<h2 id="-final-thoughts">üéØ Final Thoughts<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-final-thoughts" class="anchor" aria-hidden="true">#</a></span></h2>
<p>MediaMTX is a powerful, ready-to-use solution for real-time video streaming using WebRTC and other protocols. Its versatility and ease of setup make it an excellent choice for developers looking to implement live streaming with minimal hassle. Whether you need WebRTC for low-latency streaming or HLS for broader device compatibility, MediaMTX has got you covered.</p>
<p>Start building your WebRTC-based streaming solution today and take your media projects to the next level!</p>13:T2de8,<p>The NGINX RTMP Module is a robust, NGINX-based media streaming server that simplifies live video streaming and playback. Designed for high performance, it supports RTMP and HLS protocols, making it a go-to solution for live streaming applications.</p>
<p>Explore the demo: <a href="">Nginx RTMP module DEMO</a>.</p>
<img src="/images/mermaid/mermaid-7440292164595184b408fc81e80dbc7a.svg" alt="Mermaid diagram">
<h2 id="-why-choose-nginx-rtmp-module">üöÄ Why Choose NGINX RTMP Module?<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-why-choose-nginx-rtmp-module" class="anchor" aria-hidden="true">#</a></span></h2>
<ul>
<li>Streamlined Setup: Integrate live streaming directly into your existing NGINX server setup with <strong>minimal configuration</strong>.</li>
<li><strong>HLS Playback Support</strong>: Deliver your live streams with HLS for seamless playback across modern devices.</li>
<li>Adaptability: Extend functionality using external tools like <strong>FFmpeg</strong> for tasks such as <strong>transcoding</strong> or overlay processing.</li>
<li>Load Balancer Integration: Combine RTMP streaming with NGINX‚Äôs load balancing for efficient delivery at <strong>scale</strong>.</li>
</ul>
<h2 id="Ô∏è-how-to-stream-with-ffmpeg-on-macos">üõ†Ô∏è How to Stream with FFmpeg on macOS<span class="ml-2 opacity-0 hover:opacity-100"><a href="#Ô∏è-how-to-stream-with-ffmpeg-on-macos" class="anchor" aria-hidden="true">#</a></span></h2>
<p>Test your streaming setup by capturing video and audio input from your macOS camera and microphone using FFmpeg:</p>
<pre><code class="hljs language-bash">ffmpeg -re -f avfoundation -framerate 30 -video_size 640x480 -i <span class="hljs-string">"0"</span> -f avfoundation -i <span class="hljs-string">":0"</span> \
-c:v libx264 -vf format=uyvy422 -b:v 4000k -bufsize 8000k -maxrate 4000k -g 30 \
-c:a aac -b:a 192k -ar 48000 -af <span class="hljs-string">"equalizer=f=1000:t=q:w=1:g=5,loudnorm"</span> \
-f flv <span class="hljs-string">'rtmp://localhost:1935/live/mychannel3'</span>
</code></pre>
<p>In this example:</p>
<ul>
<li>Video &#x26; Audio Input: Captures from camera and microphone.</li>
<li>Video Encoding: Uses <code>libx264</code> codec with 4000k bitrate.</li>
<li>Audio Processing: Applies an equalizer filter and loudness normalization.</li>
<li>Output Format: Streams to the RTMP endpoint.</li>
</ul>
<h2 id="-enable-hls-playback">üì∫ Enable HLS Playback<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-enable-hls-playback" class="anchor" aria-hidden="true">#</a></span></h2>
<p>HLS playback allows you to stream live video in a format compatible with modern browsers and devices. Use HLS playback scripts to test your setup.</p>
<p>HLS playback script:</p>
<pre><code class="hljs language-html"><span class="hljs-meta">&#x3C;!DOCTYPE <span class="hljs-keyword">html</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">head</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">title</span>></span>HLS Stream<span class="hljs-tag">&#x3C;/<span class="hljs-name">title</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/hls.js@latest"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">style</span>></span><span class="css">
        <span class="hljs-selector-tag">body</span> {
            <span class="hljs-attribute">display</span>: flex;
            <span class="hljs-attribute">justify-content</span>: center;
            <span class="hljs-attribute">align-items</span>: center;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>;
        }
        <span class="hljs-selector-tag">video</span> {
            <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>;
            <span class="hljs-attribute">width</span>: <span class="hljs-number">800px</span>; <span class="hljs-comment">/* Set a width for the video */</span>
        }
    </span><span class="hljs-tag">&#x3C;/<span class="hljs-name">style</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">head</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>HLS Live Stream<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"video"</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">autoplay</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">video</span>></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">script</span>></span><span class="javascript">
    <span class="hljs-keyword">var</span> video = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'video'</span>);
    <span class="hljs-keyword">var</span> videoSrc = <span class="hljs-string">'http://localhost/hls/mystream/index.m3u8'</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Hls</span>.<span class="hljs-title function_">isSupported</span>()) {
        <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hls</span>();
        index.<span class="hljs-title function_">loadSource</span>(videoSrc);
        index.<span class="hljs-title function_">attachMedia</span>(video);
        index.<span class="hljs-title function_">on</span>(<span class="hljs-title class_">Hls</span>.<span class="hljs-property">Events</span>.<span class="hljs-property">MANIFEST_PARSED</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            video.<span class="hljs-title function_">play</span>();
        });
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (video.<span class="hljs-title function_">canPlayType</span>(<span class="hljs-string">'application/vnd.apple.mpegurl'</span>)) {
        video.<span class="hljs-property">src</span> = videoSrc; <span class="hljs-comment">// Fallback for Safari</span>
        video.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'loadedmetadata'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            video.<span class="hljs-title function_">play</span>();
        });
    }
</span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span>
</code></pre>
<h2 id="-advantages">üü¢ Advantages<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-advantages" class="anchor" aria-hidden="true">#</a></span></h2>
<ul>
<li>Ease of Use: Quickly set up live streaming with minimal configuration.</li>
<li>Flexible: Extend functionality by <strong>running executable</strong> files, such as FFmpeg, to enable additional features like transcoding or watermarking.</li>
<li>Seamless Device Support: Combine RTMP input with HLS output for universal playback.</li>
</ul>
<h2 id="-limitations">üî¥ Limitations<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-limitations" class="anchor" aria-hidden="true">#</a></span></h2>
<ul>
<li>Limited Scripting Capability: The RTMP module itself has limited scripting options, but this can be <strong>mitigated</strong> by integrating external tools like <strong>FFmpeg</strong>.</li>
</ul>
<h2 id="-get-started-now">üéØ Get Started Now<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-get-started-now" class="anchor" aria-hidden="true">#</a></span></h2>
<h3 id="1-clone-the-repository">1. Clone the repository:<span class="ml-2 opacity-0 hover:opacity-100"><a href="#1-clone-the-repository" class="anchor" aria-hidden="true">#</a></span></h3>
<p>Clone the demo project and build the Docker image:</p>
<pre><code class="hljs language-bash">git <span class="hljs-built_in">clone</span> https://gitlab.com/harry.sitohang/nginx-rtmp
<span class="hljs-built_in">cd</span> nginx-rtmp
docker build -t my-nginx-rtmp:v1 .
</code></pre>
<p>Run the Docker container with the required configuration:</p>
<pre><code class="hljs language-bash">docker <span class="hljs-built_in">rm</span> -f nginx-rtmp &#x26;&#x26; docker run -d --name nginx-rtmp \
-p 1935:1935 -p 80:80 -p 9001:9001 \
-v $(<span class="hljs-built_in">pwd</span>)/nginx.conf:/etc/nginx/nginx.conf \
-v $(<span class="hljs-built_in">pwd</span>)/tmp/hls:/tmp/hls \
-v $(<span class="hljs-built_in">pwd</span>)/var/log:/var/log/nginx \
my-nginx-rtmp:v1
</code></pre>
<h3 id="2-stream-with-ffmpeg-from-camera-and-microphone">2. Stream with FFmpeg from Camera and Microphone<span class="ml-2 opacity-0 hover:opacity-100"><a href="#2-stream-with-ffmpeg-from-camera-and-microphone" class="anchor" aria-hidden="true">#</a></span></h3>
<p>Stream live video and audio to the RTMP server:</p>
<pre><code class="hljs language-bash">ffmpeg -re -f avfoundation -framerate 30 -video_size 640x480 -i <span class="hljs-string">"0"</span> -f avfoundation -i <span class="hljs-string">":0"</span> \
-c:v libx264 -vf format=uyvy422 -b:v 4000k -bufsize 8000k -maxrate 4000k -g 30 \
-c:a aac -b:a 192k -ar 48000 -af <span class="hljs-string">"equalizer=f=1000:t=q:w=1:g=5,loudnorm"</span> \
-f flv <span class="hljs-string">'rtmp://localhost:1935/live/mychannel'</span>
</code></pre>
<h3 id="3-republish-stream-from-hls-to-oss-rtmp">3. Republish Stream from HLS to OSS RTMP<span class="ml-2 opacity-0 hover:opacity-100"><a href="#3-republish-stream-from-hls-to-oss-rtmp" class="anchor" aria-hidden="true">#</a></span></h3>
<pre><code class="hljs language-bash">ffmpeg -i http://localhost/hls/mychannel/index.m3u8 -c:v copy -c:a copy \
-f flv <span class="hljs-string">"rtmp://anotherhost:1935/live/channel"</span>
</code></pre>
<h2 id="-documentation">üìÑ Documentation<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-documentation" class="anchor" aria-hidden="true">#</a></span></h2>
<ul>
<li><a href="https://github.com/arut/nginx-rtmp-module/wiki/Directives#hls_sync">NGINX RTMP Module Directives</a></li>
<li><a href="https://github.com/tiangolo/nginx-rtmp-docker/blob/master/Dockerfile">Tiangolo‚Äôs NGINX RTMP Docker</a></li>
</ul>
<h2 id="-final-thoughts">üåü Final Thoughts<span class="ml-2 opacity-0 hover:opacity-100"><a href="#-final-thoughts" class="anchor" aria-hidden="true">#</a></span></h2>
<p>The NGINX RTMP Module is a game-changer for live streaming, offering a powerful and flexible solution. Coupled with tools like FFmpeg, you can achieve professional-grade streaming setups with <strong>minimal effort</strong>. Start building your live streaming platform today!</p>2:["$","div",null,{"className":"min-h-screen bg-white dark:bg-neutral-900","children":[["$","$Ld",null,{}],["$","div",null,{"className":"max-w-[min(65ch,90vw)] mx-auto px-4 py-12","children":[["$","div",null,{"className":"flex items-center justify-between mb-12","children":["$","div",null,{"children":["$","p",null,{"className":"text-neutral-600 dark:text-neutral-400","children":"Thoughts, tutorials, and insights about web development"}]}]}],["$","$Le",null,{"articles":[{"id":"strapi-middleware-cache","slug":"strapi-middleware-cache","title":"Implementing a Redis-Powered Cache Middleware in Strapi","excerpt":"This article dives into creating and configuring a Redis-powered cache middleware for Strapi. You‚Äôll learn how to handle dynamic caching, invalidate caches, and configure Redis seamlessly.","content":"$f","image":"/images/articles/strapi-middleware-cache.webp","published_at":"2024-12-10T12:49:00+07:00","author":"harry-osmar-sitohang","reading_time":4},{"id":"ffmpeg-wasm","slug":"ffmpeg-wasm","title":"Mastering FFMPEG WASM","excerpt":"Revolutionizing Video and Audio Processing in the Browser","content":"$10","image":"/images/articles/ffmpeg-wasm2.png","published_at":"2024-10-20T00:00:00+07:00","author":"harry-osmar-sitohang","reading_time":3},{"id":"websocket-to-ffmpeg-streaming","slug":"websocket-to-ffmpeg-streaming","title":"WebSocket to FFMPEG Streaming","excerpt":"Seamlessly Forwarding Live Streams to RTMP Channels.","content":"$11","image":"/images/articles/websocket-to-ffmpeg-streaming.png","published_at":"2024-10-02T00:00:00+07:00","author":"harry-osmar-sitohang","reading_time":2},{"id":"mediamtx-for-webrtc-streaming","slug":"mediamtx-for-webrtc-streaming","title":"MediaMTX for WebRTC Streaming","excerpt":"Unleashing the Power of WebRTC with Go's MediaMTX.","content":"$12","image":"/images/articles/mediamtx.png","published_at":"2024-10-02T00:00:00+07:00","author":"harry-osmar-sitohang","reading_time":3},{"id":"nginx-rtmp-module","slug":"nginx-rtmp-module","title":"NGINX RTMP Module","excerpt":"Unleashing the Power of NGINX RTMP Module for Media Streaming. ","content":"$13","image":"/images/articles/nginx-rtmp-module2.png","published_at":"2024-10-01T00:00:00+07:00","author":"harry-osmar-sitohang","reading_time":4}]}],["$","$L14",null,{"currentPage":1,"totalPages":1,"baseUrl":"/articles"}]]}]]}]
